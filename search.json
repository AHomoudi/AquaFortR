[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AquaFortR: Streamlining Atmospheric Science, Oceanography, Climate, and Water Research with Fortran-accelerated R",
    "section": "",
    "text": "Welcome to the enlightening journey through the pages of “AquaFortR: Streamlining Atmospheric Science, Oceanography, Climate, and Water Research with Fortran-accelerated R”. In this book, you will gain invaluable insights into seamlessly speeding up R scripts by harnessing the power of Fortran. You will acquire essential perspectives into speeding up your package using simple Fortran codes. Furthermore, you will accumulate tweaks to accelerate your scripts or packages, and supplementary reading will prove to be both advantageous and highly beneficial for further optimization, and efficiency.\n \nThis work has been funded by the German Research Foundation (DFG) through the project NFDI4Earth (DFG project no. 460036893, https://www.nfdi4earth.de/) within the German National Research Data Infrastructure (NFDI, https://www.nfdi.de/).\n \nThis book is licensed under the Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0) License (https://creativecommons.org/licenses/by-nc/4.0/).",
    "crumbs": [
      "&nbsp;"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 R\nR is a powerful and versatile open-source language and environment for statistical computing and graphics (R Core Team, 2023). R was developed to facilitate data manipulation, exploration, and visualisation, providing various statistical and graphical tools.\nThe R environment is designed for effective data handling, array and matrix operations, and is a well-developed and simple programming language (R Core Team, 2023). Its syntax is concise and expressive, making it an accessible language for newbies and seasoned programmers. R can perform tasks either by executing scripts or interactively. The latter is advantageous for beginners and during the first stages of script development. The interactive environment is accessible through command lines or various integrated development environments (IDEs), such RStudio.\nMany factors play an important role in the popularity of R. For example, the ability to produce graphics with a publication’s quality. Simultaneously, the users maintain full control over customising the plots according to their preferences and intricate details. Another significant factor is its ability to be extended to meet the user’s demand. The Comprehensive R Archive Network (CRAN) contains an extensive array of libraries and packages to extend R’s functionality for various tasks. With over 20447 available packages, the CRAN package repository is a testament to R’s versatility and adaptability.\nTidyverse is the most popular bundle of R packages for data science. It was developed by Hadley Wickham and his team. The common shared design among tidyverse packages increases the consistency across functions and makes each new function or package a little easier to comprehend and utilise (Wickham et al., 2023).\nMany packages have been developed for spatial data analysis to address various challenging tasks. R-spatial provides a rich set of packages for handling spatial or spatio-temporal data. For example, sf provides simple features access in R, which is a standardized method for encoding spatial vector data. The stars package aims to handle spatiotemporal arrays. Additionally, the terra package works with spatial data and has the ability to process large datasets on the disk when loading into memory (RAM) is not feasible.\nFurthermore, research produces a large data sets; therefore, it is essential to store them according to the FAIR principles (Findability, Accessibility, Interoperability, and Reuse of digital assets; Wilkinson et al. (2016)). NetCDF and HDF5 are among the most prominent scientific data formats owing to their numerous capabilities. The R package ncdf4 delivers a high-level R interface to data files written using Unidata’s netCDF library. Additionally, rhdf5 provides an interface between HDF5 and R.\nRegarding the integration of other programming languages, R has diverse interfaces, which are either a fundamental implementation of R or attainable via another R package (Chambers, 2016). The fundamental interfaces are .Call(), .C(), and .Fortran() to C and Fortran. The development of the Rcpp package has revolutionised seamless access to C++. Python is also accessible using the reticulate package. Finally, the Java interface was granted using the rJava package.\nIn conclusion, R is a valuable tool in the Earth System, as it can effectively tackle multifarious scientific tasks and address numerous outstanding research inquiries.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#fortran",
    "href": "intro.html#fortran",
    "title": "1  Introduction",
    "section": "1.2 Fortran",
    "text": "1.2 Fortran\nFortran, short for Formula Translation, is one of the oldest high-level programming languages. It was first developed in the 1950s, and is nonetheless widely used in scientific and engineering applications. Key features of Fortran include its ability to efficiently handle arrays and matrices, making it well-suited for numerical computations. Additionally, Fortran has a simple and straightforward syntax that makes it easy to learn and use, because it is possible to write mathematical formulas almost as they written in mathematical texts (Metcalf et al., 2018).\nFortran has been revised multiple times, with the most recent iteration being Fortran 2023. Another important feature of Fortran is its support for parallel programming, enabling developers to take advantage of multicore processors and high-performance computing architectures.\nThere are frequently numerous good reasons to integrate different programming languages to achieve tasks. Interoperability with C programming language is a feature that was introduced with Fortran 95 (Metcalf et al., 2018). Given that C is widely used for system-level programming, many of the other languages include support for C. Therefore, the C Application Programming Interface (API) can also be used to connect two non-C languages (Chirila & Lohmann, 2014). For instance, in atmospheric modelling, Fortran is used for its high performance and capcity to handle large data sets, while C is utilised for its efficiency and control over memory usage.\nNoteworthy, developing software using Fortran necessitates utilisation of its primitive procedures and developing from scratch. This is because Fortran is not similar to scripting languages (i.e. R) that requires a special environment (Masuda, 2020). However, Fortran is privileged with its persistent backward compatibility, resulting in the usability of countless (legacy) codes written decades ago.\n\nSince R was designed to streamline data analysis and statistics (Wickham, 2015) and Fortran is renowned for its high performance, it makes seance to integrate the two languages. It should be noted that both programming languages present arrays in column-major order, which makes it easier to bridge without causing confusion. Additionally, R is developed using Fortran, C, and R programming languages, and it features .Call and .External() functions that allows users to utilise compiled code from other R packages.\nDespite the development of newer programming languages, Fortran remains a popular choice for many scientists and engineers due to its reliability, efficiency, and ability to handle large amounts of data.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#installation",
    "href": "intro.html#installation",
    "title": "1  Introduction",
    "section": "1.3 Installation",
    "text": "1.3 Installation\nR\nInstallation of R differs according to the operating system:\n\nThe webpage here provides information on installing R according to the Linux distribution.\nFor Windows, the executable can be downloaded from here. Additionally, previous releases of R for Windows exit.\nFor macOS, various releases and versions are accessible here.\n\nRStudio\nAs mentioned earlier, RStudio is an IDE for R. Although it is the most prominent, other IDEs exist, such as Jupyter Notebook and Visual Studio Code. In this book, RStudio will be the main IDE. To install Rstudio, visit the posit page to download the suitable installers.\nFortran\nFortran doesn’t require an explicit installation, unlike interpreted languages such as R. The source code would be translated to the machine language using the Fortran compiler, and then it can be executed. Therefore, it is important to make sure that a Fortran compiler, i.e., the GNU Fortran (gfortran) compiler, exists in the working machine.\n\nIn the majority of Linux distributions, the GCC compilers, including gfortran, come pre-installed.\nFor Windows, installing rtools should ensure the existence of gfortran\nFor macOS, binaries for gfortran are available here. Furthermore, more information is available on R for macOS here\n\n\n\n\n\nChambers, F., John M. CRC Press Boca Raton. (2016). Extending r. http://slubdd.de/katalog?TN_libero_mab2\n\n\nChirila, D. B., & Lohmann, G. (2014). Introduction to modern fortran for the earth system sciences. Springer Berlin Heidelberg. https://books.google.de/books?id=bZCeBQAAQBAJ\n\n\nMasuda, Y. (2020). Modern fortran tutorial. Introduction. https://masuday.github.io/fortran_tutorial/introduction.html\n\n\nMetcalf, M., Reid, J., & Cohen, M. (2018). Modern fortran explained: Incorporating fortran 2018. OUP Oxford. https://books.google.de/books?id=sB1rDwAAQBAJ\n\n\nR Core Team. (2023). R: A language and environment for statistical computing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nWickham, H. (2015). Advanced r. CRC Press. https://books.google.de/books?id=FfsYCwAAQBAJ\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for data science import, tidy, transform, visualize, and model data (2nd edition). O’Reilly. http://slubdd.de/katalog?TN_libero_mab2\n\n\nWilkinson, M. D., Dumontier, M., Aalbersberg, Ij. J., Appleton, G., Axton, M., Baak, A., Blomberg, N., Boiten, J.-W., da Silva Santos, L. B., Bourne, P. E., Bouwman, J., Brookes, A. J., Clark, T., Crosas, M., Dillo, I., Dumon, O., Edmunds, S., Evelo, C. T., Finkers, R., … Mons, B. (2016). The FAIR Guiding Principles for scientific data management and stewardship. Scientific Data, 3(1), 160018. https://doi.org/10.1038/sdata.2016.18",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "scripts.html",
    "href": "scripts.html",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "",
    "text": "2.1 2D Coss-Correlation\nIn signal processing, cross-correlation is a measure of the similarity between two signals as a function of the displacement of one relative to the other (Wang, 2019). It can deliver information about the time lag between the two signals. 2D cross-correlation is often applied in computer vision for visual tracking. For example, it is used in template matching, feature detection, and motion tracking. 2D cross-correlation also plays an important role in convolutional networks and machine learning.\nIn atmospheric science, oceanography, climate, and water research, 2D cross-correlation can be applied in various ways. For example, it can be used to estimate ocean surface currents (Warren et al., 2016), cloud tracking using satellite imagery (Seelig et al., 2021), and Particle Image Velocimetry (PIV) in fluid dynamics applications (Willert & Gharib, 1991).\nThe 2D cross-correlation of an array \\(F_{(M, N)}\\), and array \\(G_{(P, Q)}\\), can be given as the array \\(CC_{(M+P-1, N+Q-1)}\\) as shown in Equation 2.1.\n\\[\nCC_{(s,t)} = \\sum_{m = 0}^{M-1}\\sum_{n = 0}^{N-1} F_{(m,n)} G_{(m-s, n-t)}\n\\tag{2.1}\\]\nwhere \\(s\\) varies between \\(-(P-1)\\) and \\((M-1)\\) while \\(t\\) varies between \\(-(Q-1)\\) and \\((N-1)\\). \\(F\\) and \\(G \\in R\\).\nNow, let us define the xcorr2D_r function as shown in Listing 2.1. The function receives two matrices or arrays a & b and return the full cross-correlation plane cc.\nListing 2.1: Cross-correlation in R\n\nxcorr2D_r0 &lt;- function(a, b) {\n  # the full CC matrix\n  cc_row &lt;- nrow(a) + nrow(b) - 1\n  cc_col &lt;- ncol(a) + ncol(b) - 1\n  cc &lt;- matrix(1:c(cc_row * cc_col),\n    byrow = FALSE, ncol = cc_col\n  )\n\n  # obtain possible shifts\n  min_row_shift &lt;- -(nrow(b) - 1)\n  max_row_shift &lt;- (nrow(a) - 1)\n  min_col_shift &lt;- -(ncol(b) - 1)\n  max_col_shift &lt;- (ncol(a) - 1)\n\n  # Padded matrix\n  rows_padded &lt;- abs(min_row_shift) +\n    nrow(a) + abs(max_row_shift)\n  cols_padded &lt;- abs(min_col_shift) +\n    ncol(a) + abs(max_col_shift)\n  # a\n  padded_a &lt;- matrix(0,\n    nrow = rows_padded,\n    ncol = cols_padded\n  )\n  padded_a[\n    (abs(min_row_shift) + 1):(abs(min_row_shift) + nrow(a)),\n    (abs(min_col_shift) + 1):(abs(min_col_shift) + ncol(a))\n  ] &lt;- a\n\n  for (icol in 1:cc_col) {\n    for (irow in 1:cc_row) {\n      icc &lt;- irow + ((icol - 1) * cc_row)\n      cols &lt;- (icol):(icol + ncol(b) - 1)\n      rows &lt;- (irow):(irow + nrow(b) - 1)\n      # b\n      padded_b &lt;- array(0,\n        dim = c(rows_padded, cols_padded)\n      )\n      padded_b[rows, cols] &lt;- b\n\n      cc[irow, icol] &lt;- sum(padded_a * padded_b)\n    }\n  }\n\n  return(cc)\n}\nMoving forward, we can define the xcorr2d_f subroutine in Fortran as shown in Listing 2.2. Subroutines are generally the approach for integrating Fortran in R. Function in Fortran return a single value with no option of altering the input arguments, while subroutines have the ability to perform complex tasks while altering input arguments. This proofs to be helpful e.g., in solving equations system.\nAnother imperative point is to define the dimension of the arrays when passing them to Fortran (i.e. explicit-shape arrays). To illustrate, m, n, p, q, k, l are the dimension of input arrays aand b, and the out array cc.\nListing 2.2: Cross-correlation in Fortran\n\nsubroutine xcorr2d_f(m, n, p, q, k, l, a, b, cc)\n   implicit none\n   integer                                :: m, n, p, q, k, l\n   double precision, dimension(m, n)      :: a\n   double precision, dimension(p, q)      :: b\n   double precision, dimension(k, l)      :: cc\n   !     dummy vars\n   integer                               :: min_row_shift, min_col_shift\n   integer                               :: max_row_shift, max_col_shift\n   integer                               :: rows_padded, cols_padded\n   integer                               :: icol, irow, icc, icol2, irow2\n   real, allocatable, dimension(:, :)    :: padded_a, padded_b\n\n   !     obtain possible shfits\n   min_row_shift = -1*(p - 1)\n   max_row_shift = m - 1\n   min_col_shift = -1*(q - 1)\n   max_col_shift = n - 1\n\n   !   Padded arrray\n   rows_padded = abs(min_row_shift) + m + abs(max_row_shift)\n   cols_padded = abs(min_col_shift) + n + abs(max_col_shift)\n   !    A\n   allocate (padded_a(rows_padded, cols_padded))\n   padded_a = 0.0\n   padded_a((abs(min_row_shift) + 1):(abs(min_row_shift) + m), &\n            (abs(min_col_shift) + 1):(abs(min_col_shift) + n)) = a\n\n   !    B\n   allocate (padded_b(rows_padded, cols_padded))\n   padded_b = 0.0\n   do icol = 1, l\n      do irow = 1, k\n         icc = irow + ((icol - 1)*k)\n         icol2 = icol + q - 1\n         irow2 = irow + p - 1\n         padded_b(irow:irow2, icol:icol2) = b\n         cc(irow, icol) = sum(padded_a*padded_b)\n         padded_b = 0.0\n      end do\n   end do\nend subroutine xcorr2d_f\nSince Fortran is a compiled language, we need to save the subroutine in xcorr2D.f90 file and compile it using: R CMD SHLIB xcorr2D.f90\nAs mentioned earlier, we need to pass the dimension of the arrays to Fortran. Therefore, it would logical to write a wrapping function for Fortran subroutine that provides other input arguments.\nIn the wrapper function (Listing 2.3), we initially require loading the shared object, which is the compiled Fortran subroutine, as dyn.load(\"path/to/xcorr2D.so\"). Furthermore, it is important to prepare other input variables for Fortran such as the dimensions of the input and output arrays. Imperatively, data types should be approached carefully. Before calling .Fortran(), all storage mode of the variables in R was converted to the appropriate type using either as.double() or as.integer(). If the wrong type is passed, it can result in a hard-to-catch error or unexpected results1.\nListing 2.3: Cross-correlation wrapping function\n\nxcorr2D_f0 &lt;- function(a, b) {\n  # Please adjust the path to your setup. In my machine,\n  dyn.load(\"AquaFortR_Codes/xcorr2D.so\")\n\n  # the full CC matrix\n  cc_row &lt;- nrow(a) + nrow(b) - 1\n  cc_col &lt;- ncol(a) + ncol(b) - 1\n  cc &lt;- matrix(1:c(cc_row * cc_col), byrow = FALSE, ncol = cc_col)\n\n  cc&lt;- .Fortran(\"xcorr2d_f\",\n    m = as.integer(dim(a)[1]),\n    n = as.integer(dim(a)[2]),\n    p = as.integer(dim(b)[1]),\n    q = as.integer(dim(b)[2]),\n    k = as.integer(cc_row),\n    l = as.integer(cc_row),\n    a = as.double(a),\n    b = as.double(b),\n    cc = as.double(cc)\n  )$cc\n\n  return(cc)\n}\nNow, we can use an example to compare the performance of the two functions. In order to do so, microbenchmark package needs to be installed, and ggplot2 is required for plotting.\nThe obtained benchmarking data allows (mbm) for a quantitative comparison of the computational efficiency between the two methods. By printing “mbm” in the console (print(mbm)) it is evident that Fortran outperforms the R implementation of 2D cross-correlation by a factor of ~10. The significance of leveraging Fortran becomes evident in Figure 2.1.\nlibrary(microbenchmark)\nlibrary(ggplot2)\n\nset.seed(72)\n# Assume a\na &lt;- structure(runif(64), dim = c(8L, 8L))\n# Assume b\nb &lt;- structure(runif(64), dim = c(8L, 8L))\nmbm &lt;- microbenchmark(\n  xcorr2D_r = xcorr2D_r0(a, b),\n  xcorr2D_f = xcorr2D_f0(a, b)\n)\n\nautoplot(mbm) +\n  stat_summary(\n    fun = \"median\",\n    geom = \"crossbar\",\n    width = 0.6,\n    colour = \"red\"\n  )\n\n\n\n\n\n\nFigure 2.1: Performance comparison of 2D Cross-correlation in R and Fortran. Median is shown as red vertical line.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "scripts.html#sec-2Dxcorr",
    "href": "scripts.html#sec-2Dxcorr",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "",
    "text": "Note\n\n\n\nPlease use the terminal tab in Rstudio or open a new terminal using Alt+Shift+R",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "scripts.html#d-convolution",
    "href": "scripts.html#d-convolution",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "\n2.2 2D Convolution",
    "text": "2.2 2D Convolution\nConvolution and cross-correlation are both operations applied to two dimensional data (e.g., matrix). Cross-correlation involves sliding a kernel (filter) across a matrix, while convolution involves sliding a flipped kernel across an matrix (Draelos, 2019). Most spatial data in earth science are is discretised resulting in large data sets. Sometimes, these data sets include noise which can obscure meaningful patterns and relationships. One of the prominent methods to remove this nose while preserving important features and structures is the Gaussian smoothing filter. Gaussian smoothing is often achieved by convolution where \\(F\\) is the original data, and \\(G\\) is the kernel representing the 2D Gaussian coefficients.\nThe 2D convolution of an array \\(F_{(M, N)}\\), and array \\(G_{(P, Q)}\\), can be given as the array \\(Conv_{(M+P-1, N+Q-1)}\\). \\(hv\\) means that \\(G\\) is flipped.\n\\[\nConv_{(s,t)} = \\sum_{m = 0}^{M-1}\\sum_{n = 0}^{N-1} F_{(m,n)} G_{(m-s, n-t)}^{hv}\n\\tag{2.2}\\]\nwhere \\(s\\) varies between \\(-(P-1)\\) and \\((M-1)\\) while \\(t\\) varies between \\(-(Q-1)\\) and \\((N-1)\\). \\(F\\) and \\(G \\in R\\).\nIndeed, it is possible to flip the second array and utilise the functions from Section 2.1. Nevertheless, our focus is on the comprehensive workflow. Listing 2.4 presents the implementation of convolution in R, whereas Listing 2.5 demonstrates the Fortran version.\n\n\n\nListing 2.4: Convolution in R\n\nconv2D_r0 &lt;- function(a, b) {\n  # the full convolution matrix\n  conv_row &lt;- nrow(a) + nrow(b) - 1\n  conv_col &lt;- ncol(a) + ncol(b) - 1\n  conv &lt;- matrix(1:c(conv_row * conv_col), byrow = FALSE, ncol = conv_col)\n\n  # obtain possible shifts\n  min_row_shift &lt;- -(nrow(b) - 1)\n  max_row_shift &lt;- (nrow(a) - 1)\n  min_col_shift &lt;- -(ncol(b) - 1)\n  max_col_shift &lt;- (ncol(a) - 1)\n\n  # Padded matrix\n  rows_padded &lt;- abs(min_row_shift) + nrow(a) + abs(max_row_shift)\n  cols_padded &lt;- abs(min_col_shift) + ncol(a) + abs(max_col_shift)\n  # a\n  padded_a &lt;- matrix(0, nrow = rows_padded, ncol = cols_padded)\n  padded_a[\n    (abs(min_row_shift) + 1):(abs(min_row_shift) + nrow(a)),\n    (abs(min_col_shift) + 1):(abs(min_col_shift) + ncol(a))\n  ] &lt;- a\n\n  for (icol in 1:conv_col) {\n    for (irow in 1:conv_row) {\n      iconv &lt;- irow + ((icol - 1) * conv_row)\n      cols &lt;- (icol):(icol + ncol(b) - 1)\n      rows &lt;- (irow):(irow + nrow(b) - 1)\n      # b\n      padded_b &lt;- array(0, dim = c(rows_padded, cols_padded))\n      # flip the kernel i.e. b\n      padded_b[rows, cols] &lt;- b[nrow(b):1, ncol(b):1]\n\n      conv[irow, icol] &lt;- sum(padded_a * padded_b)\n    }\n  }\n\n  return(conv)\n}\n\n\n\n\n\n\n\nListing 2.5: Convolution in Fortran\n\nsubroutine conv2d_f(m, n, p, q, k, l, a, b, conv)\n   implicit none\n   integer                                :: m, n, p, q, k, l, i, j\n   double precision, dimension(m, n)      :: a\n   double precision, dimension(p, q)      :: b\n   double precision, dimension(k, l)      :: conv\n   !     dummy vars\n   integer                               :: min_row_shift, min_col_shift\n   integer                               :: max_row_shift, max_col_shift\n   integer                               :: rows_padded, cols_padded\n   integer                               :: icol, irow, iconv, icol2, irow2\n   real, allocatable, dimension(:, :)    :: padded_a, padded_b\n\n   !     obtain possible shfits\n   min_row_shift = -1*(p - 1)\n   max_row_shift = m - 1\n   min_col_shift = -1*(q - 1)\n   max_col_shift = n - 1\n\n\n   !   Padded arrray\n   rows_padded = abs(min_row_shift) + m + abs(max_row_shift)\n   cols_padded = abs(min_col_shift) + n + abs(max_col_shift)\n   !    A\n   allocate (padded_a(rows_padded, cols_padded))\n   padded_a = 0.0\n   padded_a((abs(min_row_shift) + 1):(abs(min_row_shift) + m), &\n            (abs(min_col_shift) + 1):(abs(min_col_shift) + n)) = a\n\n   !    B\n   allocate (padded_b(rows_padded, cols_padded))\n   padded_b = 0.0\n   do icol = 1, l\n      do irow = 1, k\n         iconv = irow + ((icol - 1)*k)\n         icol2 = icol + q - 1\n         irow2 = irow + p - 1\n         padded_b(irow:irow2, icol:icol2) = b(p:1:-1,q:1:-1)\n         conv(irow, icol) = sum(padded_a*padded_b)\n         padded_b = 0.0\n      end do\n   end do\nend subroutine conv2d_f\n\n\n\n\nThe gfortran compiler is also capable of creating shared libraries. It allows for easy addition of other flags, such as enabling the generation of the run-time check (-fcheck=all). The code below shows two options for compiling conv2D.f90 by R or the gfortran compiler.\n\n# R\nR CMD SHLIB conv2D.f90\n\n# gfortran\ngfortran -fpic -shared conv2D.f90 -o conv2D.so\n\nIn R wrapper function, .C64() from dotCall64 package will be used instead of .Fortran(). According to Gerber et al. (2018), .C64() transcends other foreign function interfaces in many aspects:\n\nIt supports long vectors.\nThe SIGNATURE argument ensures that the interfaced R objects are of the specified types\nThe INTENT argument helps avoid unnecessary copies of R objects between languages. It is very important when working with large data sets.\n\nIn Listing 2.6, the basic input arguments, such as the dimensions of input and output arrays, are prepared. Afterwards, the SIGNATURE is defined as six integers and three doubles corresponding to the required types in the subroutine. INTENT will ensure that only the conv argument is copied between R and Fortran. This is particularly important in large productions, where coping the subroutine parameters can extend beyond the available memory (RAM).\n\n\n\nListing 2.6: Convolution wrapping function\n\nconv2D_f0 &lt;- function(a, b) {\n  require(dotCall64)\n  dyn.load(\"AquaFortR_Codes/conv2D.so\")\n\n  m &lt;- nrow(a)\n  n &lt;- ncol(b)\n\n  p &lt;- nrow(b)\n  q &lt;- ncol(b)\n  # the full convolution matrix\n  conv_row &lt;- m + p - 1\n  conv_col &lt;- n + q - 1\n  conv &lt;- matrix(0,\n    ncol = conv_col,\n    nrow = conv_row\n  )\n\n  conv &lt;- .C64(\"conv2d_f\",\n    SIGNATURE = c(\n      rep(\"integer\", 6),\n      rep(\"double\", 3)),\n    INTENT = c(rep(\"r\",8), \"rw\"),\n    m, n, p, q,\n    k = conv_row,\n    l = conv_col,\n    a = a, b = b,\n    conv = conv\n  )$conv\n\n  return(conv)\n}\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nA Gaussian smoothing filter can be applied to an array a using b as the Gaussian kernel or the 2D Gaussian coefficients. However, the convolution and cross-correlation can be optimised using the Fast Fourier Transform (FFT). See Chapter 4.\n\n\n\nlibrary(microbenchmark)\nlibrary(ggplot2)\n\n\nset.seed(72)\n# Assume a\na &lt;- structure(runif(64), dim = c(8L, 8L))\n# Assume b\nb &lt;- structure(runif(64), dim = c(8L, 8L))\nmbm &lt;- microbenchmark(\n  conv2D_r = conv2D_r0(a, b),\n  conv2D_f = conv2D_f0(a, b)\n)\n\nautoplot(mbm) +\n  stat_summary(\n    fun = \"mean\",\n    geom = \"crossbar\",\n    width = 0.6,\n    colour = \"red\"\n  )\n\n\n\n\n\n\nFigure 2.2: Performance comparison of 2D Convolution in R and Fortran. Median is shown as red vertical line.\n\n\n\n\nSimilar to cross-correlation calculation, the Fortran implementation of convolution outperforms the R one by a factor of ~10. Performing convolution in large data set using R and Fortran is beneficial since it reduce the required computational resources.\n\n\n\n\n\n\nQuestion\n\n\n\nAfter learning about .Fortran() and .C64(), you can use one of the two examples above and compare the performance of the two interfaces using microbenchmark(). Which function is faster?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "scripts.html#convective-available-potential-energy-cape",
    "href": "scripts.html#convective-available-potential-energy-cape",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "\n2.3 Convective Available Potential Energy (CAPE)",
    "text": "2.3 Convective Available Potential Energy (CAPE)\n\nAccording to the Glossary of Meteorology, CAPE is “the potential energy of an air parcel due to positive buoyancy, which is a useful tool for forecasting, parameterising, and estimating the potential updraft strength of convective clouds.” CAPE is calculated as follows (Stull, 2016):\n\\[\nCAPE =  R_d \\sum_{p_{LFC}}^{p_{EL}} (T_p - T_v) . ln(\\frac{p_{bottom}}{p_{top}})\n\\tag{2.3}\\]\nwhere \\(R_d\\) is the gas constant for dry air, \\(T_p\\) is the parcel temperature, \\(T_e\\) is the environment temperature, \\(p\\) is pressure, \\(LFC\\) is the Level of Free Convection, and \\(EL\\) is the Equilibrium Level.\nUnder a warming climate, CAPE is expected to increase (Chen et al., 2020), which can result in an elevated risk of thunderstorms. It is crucial for humanity to quantify the future risk for proper preparation and mitigation. Typically, thunderstorms are investigated with convective-permitting modelling (CPM) where the horizontal resolution is less than 4km. CPM simulations produce vast amount of data sets, and CAPE estimation at a specific gridpoint and time is an integration along the vertical profile (@#eq-cape).\nGiven the rapid advancements in computing power, it is anticipated that CPM is expected to be performed at finer horizontal and vertical resolution, thereby increasing the complexity of estimating CAPE. It is essential that the enhancement of computing power is accompanied by responsible management and allocation of these resources.\nSince CAPE calculation scripts are highly complex and lengthy, the necessary codes are only available in supplementary materials. Additionally, to test the two implementations of CAPE, the AquaFortR package should be installed to utilise the example data. See Listing 2.7.\n\n\n\nListing 2.7: CAPE implementation in R and Fortran\n\nif (!require(AquaFortR)) {\n  remotes::install_github(\"AHomoudi/AquaFortR\", subdir = \"RPackage\")\n}\n\nlibrary(AquaFortR)\ndata(\"radiosonde\")\n\nTemperature &lt;- radiosonde$temp + 273.15 # K\nDewpoint &lt;- radiosonde$dpt + 273.15 # K\nPressure &lt;- radiosonde$pressure # hPa\n# Mixing ratio\nMixingRatio &lt;- mixing_ratio_from_dewpoint(Dewpoint, Pressure)\nt_parcel &lt;- Temperature[1]\ndwpt_parcel &lt;- Dewpoint[1]\nmr_parcel &lt;- MixingRatio[1]\n\nsource(\"AquaFortR_Codes/cape_r.R\")\nsource(\"AquaFortR_Codes/cape_f.R\")\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nForemost, the Fortran subroutine need to be complied as shown in previous sections. The path to the shared library cape_f.so in cape_f.R file should be adapted to the correct path.\n\n\nAs mentioned, integration between R and Fortran should be accomplished through subroutines. Nevertheless, some calculations are complex, and using functions or other subroutines is inevitable. In cape.f90, a module containing all the required utilities was written, and then the main subroutine was included. The approach ensures cape_f has access to the module and is simultaneously available to R.\nExploring Figure 2.3, it is evident that the implementation of Fortran is faster than R by a factor of ~28, proofing that integrating Fortran in R is vital for performance and beneficial for the environment.\n\nlibrary(microbenchmark)\nlibrary(ggplot2)\n\nmbm &lt;- microbenchmark(\n  cape_r = cape_r0(t_parcel, dwpt_parcel, mr_parcel,\n    Pressure, Temperature, MixingRatio,\n    vtc = TRUE\n  ),\n  cape_f = cape_f0(t_parcel, dwpt_parcel, mr_parcel,\n    Pressure, Temperature, MixingRatio,\n    vtc = TRUE\n  )\n)\n\nautoplot(mbm) +\n  stat_summary(\n    fun = \"mean\",\n    geom = \"crossbar\",\n    width = 0.6,\n    colour = \"red\"\n  )\n\n\n\n\n\n\nFigure 2.3: Performance comparison of CAPE in R and Fortran\n\n\n\n\n\n\n\n\nChen, J., Dai, A., Zhang, Y., & Rasmussen, K. L. (2020). Changes in convective available potential energy and convective inhibition under global warming. Journal of Climate, 33(6), 2025–2050. https://doi.org/10.1175/JCLI-D-19-0461.1\n\n\nDraelos, R. (2019). Convolution vs. Cross-correlation. In Glass Box. https://glassboxmedicine.com/2019/07/26/convolution-vs-cross-correlation/\n\n\nGerber, F., Mösinger, K., & Furrer, R. (2018). dotCall64: An r package providing an efficient interface to compiled c, c++, and fortran code supporting long vectors. SoftwareX, 7, 217–221. https://doi.org/https://doi.org/10.1016/j.softx.2018.06.002\n\n\nSeelig, T., Deneke, H., Quaas, J., & Tesche, M. (2021). Life Cycle of Shallow Marine Cumulus Clouds From Geostationary Satellite Observations. Journal of Geophysical Research: Atmospheres, 126(22). https://doi.org/10.1029/2021JD035577\n\n\nStull, R. (2016). Practical meteorology: An algebra-based survey of atmospheric science. AVP International, University of British Columbia. https://books.google.de/books?id=xP2sDAEACAAJ\n\n\nWang, C. (2019). Kernel learning for visual perception. https://doi.org/10.32657/10220/47835\n\n\nWarren, M. A., Quartly, G. D., Shutler, J. D., Miller, P. I., & Yoshikawa, Y. (2016). Estimation of ocean surface currents from maximum cross correlation applied to GOCI geostationary satellite remote sensing data over the tsushima (korea) straits. Journal of Geophysical Research: Oceans, 121(9), 6993–7009. https://doi.org/https://doi.org/10.1002/2016JC011814\n\n\nWillert, C. E., & Gharib, M. (1991). Digital particle image velocimetry. Experiments in Fluids, 10(4), 181–193. https://doi.org/10.1007/BF00190388",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "scripts.html#footnotes",
    "href": "scripts.html#footnotes",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "",
    "text": "Writing R Extensions, 5.2 Interface functions .C and .Fortran↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "package.html",
    "href": "package.html",
    "title": "3  Accelerate R Packages with Fortran",
    "section": "",
    "text": "3.1 Brief Introduction to R Packages",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Accelerate R Packages with Fortran</span>"
    ]
  },
  {
    "objectID": "package.html#brief-introduction-to-r-packages",
    "href": "package.html#brief-introduction-to-r-packages",
    "title": "3  Accelerate R Packages with Fortran",
    "section": "",
    "text": "3.1.1 devtools package",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Accelerate R Packages with Fortran</span>"
    ]
  },
  {
    "objectID": "package.html#developing-aquafortr-package",
    "href": "package.html#developing-aquafortr-package",
    "title": "3  Accelerate R Packages with Fortran",
    "section": "3.2 Developing AquaFortR Package",
    "text": "3.2 Developing AquaFortR Package\n\n3.2.1 Fortran subroutine\niso_c_binidng \n\n\n3.2.2 R function\n\n\n3.2.3 C funtions\n\nC to Fortran\nR to C\n\n\n\n3.2.4 Package’s files",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Accelerate R Packages with Fortran</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "4  Conclusions and Optimization Insights",
    "section": "",
    "text": "positive features of R\npositive features of Fortran \nWhy .Fortran() should not be used. dotCall64 is recommended for scripts.\nMention the memory allocation issues related to .Fortran\nOpenMp implementation in Fortran, Romp\nExplain how beneficial R, Fortran with OpenMP is. For examples calculating cape for each vertical profile in a high resolution (1-4km) climate simulation (years) output (nlat, lon, nlevels, ntime) can be accelerated by passing the whole input arrays from R to Fortran, then loop over (nlat, lon, ntime) with OpenMP.\nThe cross-correlation can be speed up by using FFT. Also, in Fortran, the FFTW C library can be used.\nPossibility of calling BLAS, LAPACK and LINPACK linear algebra functions\nFortran using C (R_ext/BLAS.h, R_ext/Lapack.h and R_ext/Linpack.h)\nFinal words why packaging is better.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Conclusions and Optimization Insights</span>"
    ]
  },
  {
    "objectID": "further_reading.html",
    "href": "further_reading.html",
    "title": "5  Further Reading",
    "section": "",
    "text": "Fortran and R – Speed Things Up by Steve Pittard\nThe Need for Speed Part 1: Building an R Package with Fortran (or C) by Avraham Adler\nThe Need for Speed Part 2: C++ vs. Fortran vs. C by Avraham Adler\nWriting R Extensions by R Core Team\nModern Fortran Tutorial by Yutaka Masuda\nExtend R with Fortran by Yutaka Masuda\nAdvanced R by Hadley Wickham\nFortran 90 Tutorial by Stanford University\nFortran Libraries by Fortran Wiki\nFortran Best Practices by Fortran Community\nFortran 90 Reference Card by Michael Goerz.\nHands-On Programming with R by Garrett Grolemund\nr-spatial by Edzer Pebesma, Marius Appel, and Daniel Nüst\nSpatial Data Science\nR for Data Science (2e) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund\nIntroduction to Environmental Data Science by Jerry Davis",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Further Reading</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Chambers, F., John M. CRC Press Boca Raton. (2016). Extending\nr. http://slubdd.de/katalog?TN_libero_mab2\n\n\nChen, J., Dai, A., Zhang, Y., & Rasmussen, K. L. (2020). Changes in\nconvective available potential energy and convective inhibition under\nglobal warming. Journal of Climate, 33(6), 2025–2050.\nhttps://doi.org/10.1175/JCLI-D-19-0461.1\n\n\nChirila, D. B., & Lohmann, G. (2014). Introduction to modern\nfortran for the earth system sciences. Springer Berlin Heidelberg.\nhttps://books.google.de/books?id=bZCeBQAAQBAJ\n\n\nDraelos, R. (2019). Convolution vs. Cross-correlation. In Glass\nBox. https://glassboxmedicine.com/2019/07/26/convolution-vs-cross-correlation/\n\n\nGerber, F., Mösinger, K., & Furrer, R. (2018). dotCall64: An r\npackage providing an efficient interface to compiled c, c++, and fortran\ncode supporting long vectors. SoftwareX, 7, 217–221.\nhttps://doi.org/https://doi.org/10.1016/j.softx.2018.06.002\n\n\nMasuda, Y. (2020). Modern fortran tutorial. Introduction. https://masuday.github.io/fortran_tutorial/introduction.html\n\n\nMetcalf, M., Reid, J., & Cohen, M. (2018). Modern fortran\nexplained: Incorporating fortran 2018. OUP Oxford. https://books.google.de/books?id=sB1rDwAAQBAJ\n\n\nR Core Team. (2023). R: A language and environment for statistical\ncomputing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nSeelig, T., Deneke, H., Quaas, J., & Tesche, M. (2021). Life Cycle of Shallow Marine Cumulus Clouds From\nGeostationary Satellite Observations. Journal of Geophysical\nResearch: Atmospheres, 126(22). https://doi.org/10.1029/2021JD035577\n\n\nStull, R. (2016). Practical meteorology: An algebra-based survey of\natmospheric science. AVP International, University of British\nColumbia. https://books.google.de/books?id=xP2sDAEACAAJ\n\n\nWang, C. (2019). Kernel learning for visual perception. https://doi.org/10.32657/10220/47835\n\n\nWarren, M. A., Quartly, G. D., Shutler, J. D., Miller, P. I., &\nYoshikawa, Y. (2016). Estimation of ocean surface currents from maximum\ncross correlation applied to GOCI geostationary satellite remote sensing\ndata over the tsushima (korea) straits. Journal of Geophysical\nResearch: Oceans, 121(9), 6993–7009. https://doi.org/https://doi.org/10.1002/2016JC011814\n\n\nWickham, H. (2015). Advanced r. CRC Press. https://books.google.de/books?id=FfsYCwAAQBAJ\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for\ndata science import, tidy, transform, visualize, and model data\n(2nd edition). O’Reilly. http://slubdd.de/katalog?TN_libero_mab2\n\n\nWilkinson, M. D., Dumontier, M., Aalbersberg, Ij. J., Appleton, G.,\nAxton, M., Baak, A., Blomberg, N., Boiten, J.-W., da Silva Santos, L.\nB., Bourne, P. E., Bouwman, J., Brookes, A. J., Clark, T., Crosas, M.,\nDillo, I., Dumon, O., Edmunds, S., Evelo, C. T., Finkers, R., … Mons, B.\n(2016). The FAIR Guiding Principles for scientific\ndata management and stewardship. Scientific Data,\n3(1), 160018. https://doi.org/10.1038/sdata.2016.18\n\n\nWillert, C. E., & Gharib, M. (1991). Digital\nparticle image velocimetry. Experiments in Fluids,\n10(4), 181–193. https://doi.org/10.1007/BF00190388",
    "crumbs": [
      "References"
    ]
  }
]