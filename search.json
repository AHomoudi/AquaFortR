[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AquaFortR: Streamlining Atmospheric Science, Oceanography, Climate, and Water Research with Fortran-accelerated R",
    "section": "",
    "text": "Welcome to the enlightening journey through the pages of “AquaFortR: Streamlining Atmospheric Science, Oceanography, Climate, and Water Research with Fortran-accelerated R”. In this book, you will gain invaluable insights into seamlessly integrating Fortran into R scripts by harnessing the power of Fortran. You will acquire invaluable insights into how to speed up your package using simple C and Fortran codes. Furthermore, you will accumulate tweaks to further accelerate your scripts or packages, and further reading will prove to be both advantageous and highly beneficial for further optimization, and efficiency.\n \nThis work has been funded by the German Research Foundation (DFG) through the project NFDI4Earth (DFG project no. 460036893, https://www.nfdi4earth.de/) within the German National Research Data Infrastructure (NFDI, https://www.nfdi.de/).\n \nThis book is licensed under the Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0) License (https://creativecommons.org/licenses/by-nc/4.0/).",
    "crumbs": [
      "&nbsp;"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 R\nR is a powerful and versatile open-source language and environment for statistical computing and graphics (R Core Team, 2023). R was developed to facilitate data manipulation, exploration, and visualisation, providing various statistical and graphical tools.\nThe R environment is designed for effective data handling, array and matrix operations, and is a well-developed and simple programming language (R Core Team, 2023). Its syntax is concise and expressive, making it an accessible language for newbies and seasoned programmers. R can perform tasks either by executing scripts or interactively. The latter is advantageous for beginners and during the first stages of script development. The interactive environment is accessible through command lines or various integrated development environments (IDEs), such RStudio.\nMany factors play an important role in the popularity of R. For example, the ability to produce graphics with a publication’s quality. Simultaneously, the users maintain full control over customising the plots according to their preferences and intricate details. Another significant factor is its ability to be extended to fit the user’s demand. The Comprehensive R Archive Network (CRAN) contains an extensive array of libraries and packages to extend R’s functionality for various tasks. With over 20447 available packages, the CRAN package repository is a testament to R’s versatility and adaptability.\nTidyverse is the most popular bundle of R packages for data science. It was developed by Hadley Wickham and his team. The common shared design among tidyverse packages increases the consistency across functions and makes each new function or package a little easier to comprehend and utilise (Wickham et al., 2023).\nMany packages have been developed for spatial data analysis to address various challenging tasks. R-spatial provides a rich set of packages for handling spatial or spatio-temporal data. For example, sf provides simple features access in R, which is a standardized method for encoding spatial vector data. The stars package aims to handle spatiotemporal arrays. Additionally, the terra package works with spatial data and has the ability to process large datasets on the disk when loading into memory (RAM) is not feasible.\nFurthermore, research produces a large data sets; therefore, it is essential to store them according to the FAIR principles (Findability, Accessibility, Interoperability, and Reuse of digital assets; Wilkinson et al. (2016)). NetCDF and HDF5 are among the most prominent scientific data formats owing to their numerous capabilities. The R package ncdf4 delivers a high-level R interface to data files written using Unidata’s netCDF library. Additionally, rhdf5 provides an interface between HDF5 and R.\nRegarding the integration of other programming languages, R has diverse interfaces, which are either a fundamental implementation of R or attainable via another R package (Chambers, 2016). The fundamental interfaces are .Call(), .C(), and .Fortran() to C and Fortran. The development of the Rcpp package has revolutionised seamless access to C++. Python is also accessible using the reticulate package. Finally, the Java interface was granted using the rJava package.\nIn conclusion, R is a valuable tool in the Earth System, as it can effectively tackle multifarious scientific tasks and address numerous outstanding research inquiries.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#fortran",
    "href": "intro.html#fortran",
    "title": "1  Introduction",
    "section": "1.2 Fortran",
    "text": "1.2 Fortran\nFortran, short for Formula Translation, is one of the oldest high-level programming languages. It was first developed in the 1950s, and is nonetheless widely used in scientific and engineering applications. Key features of Fortran include its ability to efficiently handle arrays and matrices, making it well-suited for numerical computations. Additionally, Fortran has a simple and straightforward syntax that makes it easy to learn and use, because it is possible to write mathematical formulas almost as they written in mathematical texts (Metcalf et al., 2018).\nFortran has been revised multiple times, with the most recent iteration being Fortran 2023. Another important feature of Fortran is its support for parallel programming, enabling developers to take advantage of multicore processors and high-performance computing architectures.\nThere are frequently numerous good reasons to integrate different programming languages to achieve tasks. Interoperability with C programming language is a feature that was introduced with Fortran 95 (Metcalf et al., 2018). Given that C is widely used for system-level programming, many of the other languages include support for C. Therefore, the C Application Programming Interface (API) can also be used to connect two non-C languages (Chirila & Lohmann, 2014). For instance, in atmospheric modelling, Fortran is used for its high performance and capcity to handle large data sets, while C is utilised for its efficiency and control over memory usage.\nNoteworthy, developing software using Fortran necessitates utilisation of its primitive procedures and developing from scratch. This is because Fortran is not similar to scripting languages (i.e. R) that requires a special environment (Masuda, 2020). However, Fortran is privileged with its persistent backward compatibility, resulting in the usability of countless (legacy) codes written decades ago.\n\nSince R was designed to streamline data analysis and statistics (Wickham, 2015) and Fortran is renowned for its high performance, it makes seance to integrate the two languages. It should be noted that both programming languages present arrays in column-major order, which makes it easier to bridge without causing confusion. Additionally, R is developed using Fortran, C, and R programming languages, and it features .Call and .External() functions that allows users to utilise compiled code from other R packages.\nDespite the development of newer programming languages, Fortran remains a popular choice for many scientists and engineers due to its reliability, efficiency, and ability to handle large amounts of data.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#installation",
    "href": "intro.html#installation",
    "title": "1  Introduction",
    "section": "1.3 Installation",
    "text": "1.3 Installation\nR\nInstallation of R differs according to the operating system:\n\nThe webpage here provides information on installing R according to the Linux distribution.\nFor Windows, The executable can be downloaded from here. Additionally, Previous releases of R for Windows exit.\nFor macOS, various releases and versions are accessible here.\n\nRStudio\nAs mentioned earlier, RStudio is an IDE for R. Although it is the most prominent, other IDEs exist, such as Jupyter Notebook and Visual Studio Code. In this book, RStudio will be the main IDE. To install Rstudio, visit the posit page to download the suitable installers.\nFortran\nFortran doesn’t require an explicit installation, unlike interpreted languages such as R. The source code would be translated to the machine language using the Fortran compiler, and then it can be executed. Therefore, it is important to make sure that a Fortran compiler, i.e., the GNU Fortran (gfortran) compiler, exists in the working machine.\n\nIn the majority of Linux distributions, the GCC compilers, including gfortran, come pre-installed.\nFor Windows, installing RTools should ensure the existence of gfortran\nFor macOS, binaires for gfortran are avaiable here. Furthermore, more information is available on R for macOS here\n\n\n\n\n\nChambers, F., John M. CRC Press Boca Raton. (2016). Extending r.http://slubdd.de/katalog?TN_libero_mab2 \n\n\nChirila, D. B., & Lohmann, G. (2014). Introduction to modern fortran for the earth system sciences. Springer Berlin Heidelberg. https://books.google.de/books?id=bZCeBQAAQBAJ\n\n\nMasuda, Y. (2020). Modern fortran tutorial. Introduction. https://masuday.github.io/fortran_tutorial/introduction.html\n\n\nMetcalf, M., Reid, J., & Cohen, M. (2018). Modern fortran explained: Incorporating fortran 2018. OUP Oxford. https://books.google.de/books?id=sB1rDwAAQBAJ\n\n\nR Core Team. (2023). R: A language and environment for statistical computing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nWickham, H. (2015). Advanced r. CRC Press. https://books.google.de/books?id=FfsYCwAAQBAJ\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for data science import, tidy, transform, visualize, and model data (2nd edition). O’Reilly.http://slubdd.de/katalog?TN_libero_mab2 \n\n\nWilkinson, M. D., Dumontier, M., Aalbersberg, Ij. J., Appleton, G., Axton, M., Baak, A., Blomberg, N., Boiten, J.-W., da Silva Santos, L. B., Bourne, P. E., Bouwman, J., Brookes, A. J., Clark, T., Crosas, M., Dillo, I., Dumon, O., Edmunds, S., Evelo, C. T., Finkers, R., … Mons, B. (2016). The FAIR Guiding Principles for scientific data management and stewardship. Scientific Data, 3(1), 160018. https://doi.org/10.1038/sdata.2016.18",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "scripts.html",
    "href": "scripts.html",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "",
    "text": "2.1 2D Coss-Correlation\nIn signal processing, cross-correlation is a measure of the similarity between two signals as a function of the displacement of one relative to the other (Wang, 2019). It can deliver information about the time lag between the two signals. Cross-correlation is often applied in computer vision for visual tracking. For example, it is used in template matching, feature detection, and motion tracking. 2D cross-correlation also plays an important role in convolutional networks and machine learning.\nIn atmospheric science, oceanography, climate, and water research, 2D cross-correlation can be applied in various ways. For example, it can be used to estimate ocean surface currents (Warren et al., 2016), cloud tracking using satellite imagery (Seelig et al., 2021), and Particle Image Velocimetry (PIV) in fluid dynamics applications (Willert & Gharib, 1991).\nThe 2D cross-correlation of an array \\(F\\), with dimension \\((M, N)\\), and array \\(G\\), with dimension \\((P, Q)\\), can be given as the array \\(CC\\) that has a dimension of \\((M+P-1, N+Q-1)\\).\n\\[\nCC_{(s,t)} = \\sum_{m = 0}^{M-1}\\sum_{n = 0}^{N-1} F_{(m,n)} G_{(m-s, n-t)}\n\\tag{2.1}\\]\nwhere \\(s\\) varies between \\(-(P-1)\\) and \\((M-1)\\) while \\(t\\) varies between \\(-(Q-1)\\) and \\((N-1)\\). \\(F\\) and \\(G \\in R\\).\nNow, let us define the xcorr2D_r function as shown in Listing 2.1. The function receives two matrices or arrays a & b and return the full cross-correlation plane cc.\nListing 2.1: Cross-correlation in R\n\nxcorr2D_r0 &lt;- function(a, b) {\n  # the full CC matrix\n  cc_row &lt;- nrow(a) + nrow(b) - 1\n  cc_col &lt;- ncol(a) + ncol(b) - 1\n  cc &lt;- matrix(1:c(cc_row * cc_col),\n    byrow = FALSE, ncol = cc_col\n  )\n\n  # obtain possible shifts\n  min_row_shift &lt;- -(nrow(b) - 1)\n  max_row_shift &lt;- (nrow(a) - 1)\n  min_col_shift &lt;- -(ncol(b) - 1)\n  max_col_shift &lt;- (ncol(a) - 1)\n\n  # Padded matrix\n  rows_padded &lt;- abs(min_row_shift) +\n    nrow(a) + abs(max_row_shift)\n  cols_padded &lt;- abs(min_col_shift) +\n    ncol(a) + abs(max_col_shift)\n  # a\n  padded_a &lt;- matrix(0,\n    nrow = rows_padded,\n    ncol = cols_padded\n  )\n  padded_a[\n    (abs(min_row_shift) + 1):(abs(min_row_shift) + nrow(a)),\n    (abs(min_col_shift) + 1):(abs(min_col_shift) + ncol(a))\n  ] &lt;- a\n\n  for (icol in 1:cc_col) {\n    for (irow in 1:cc_row) {\n      icc &lt;- irow + ((icol - 1) * cc_row)\n      cols &lt;- (icol):(icol + ncol(b) - 1)\n      rows &lt;- (irow):(irow + nrow(b) - 1)\n      # b\n      padded_b &lt;- array(0,\n        dim = c(rows_padded, cols_padded)\n      )\n      padded_b[rows, cols] &lt;- b\n\n      cc[irow, icol] &lt;- sum(padded_a * padded_b)\n    }\n  }\n\n  return(cc)\n}\nMoving forward, we can define the xcorr2d_f subroutine in Fortran as shown in Listing 2.2. Subroutines are generally the approach for integrating Fortran in R. Function in Fortran return a single value with no option of altering the input arguments, while subroutines have the ability to perform complex tasks while altering input arguments. This proofs to be helpful e.g., in solving equations system.\nAnother imperative point is to define the dimension of the arrays when passing them to Fortran (i.e. explicit-shape arrays). To illustrate, m, n, p, q, k, l are the dimension of input arrays aand b, and the out array cc.\nListing 2.2: Cross-correlation in Fortran\n\nsubroutine xcorr2d_f(m, n, p, q, k, l, a, b, cc)\n   implicit none\n   integer                                :: m, n, p, q, k, l\n   double precision, dimension(m, n)      :: a\n   double precision, dimension(p, q)      :: b\n   double precision, dimension(k, l)      :: cc\n   !     dummy vars\n   integer                               :: min_row_shift, min_col_shift\n   integer                               :: max_row_shift, max_col_shift\n   integer                               :: rows_padded, cols_padded\n   integer                               :: icol, irow, icc, icol2, irow2\n   real, allocatable, dimension(:, :)    :: padded_a, padded_b\n\n   !     obtain possible shfits\n   min_row_shift = -1*(p - 1)\n   max_row_shift = m - 1\n   min_col_shift = -1*(q - 1)\n   max_col_shift = n - 1\n\n   !   Padded arrray\n   rows_padded = abs(min_row_shift) + m + abs(max_row_shift)\n   cols_padded = abs(min_col_shift) + n + abs(max_col_shift)\n   !    A\n   allocate (padded_a(rows_padded, cols_padded))\n   padded_a = 0.0\n   padded_a((abs(min_row_shift) + 1):(abs(min_row_shift) + m), &\n            (abs(min_col_shift) + 1):(abs(min_col_shift) + n)) = a\n\n   !    B\n   allocate (padded_b(rows_padded, cols_padded))\n   padded_b = 0.0\n   do icol = 1, l\n      do irow = 1, k\n         icc = irow + ((icol - 1)*k)\n         icol2 = icol + q - 1\n         irow2 = irow + p - 1\n         padded_b(irow:irow2, icol:icol2) = b\n         cc(irow, icol) = sum(padded_a*padded_b)\n         padded_b = 0.0\n      end do\n   end do\nend subroutine xcorr2d_f\nSince Fortran is a compiled language, we need to save the subroutine in xcorr2D.f90 file and compile it using: R CMD SHLIB xcorr2D.f90\nAs mentioned earlier, we need to pass the dimension of the arrays to Fortran. Therefore, it would logical to write a wrapping function for Fortran subroutine that provides other input arguments.\nIn the wrapper function (Listing 2.3), we initially require loading the shared object, which is the compiled Fortran subroutine, as dyn.load(\"path/to/xcorr2D.so\"). Furthermore, it is important to prepare other input variables for Fortran such as the dimensions of the input and output arrays. Imperatively, data types should be approached carefully. Before calling .Fortran(), all storage mode of the variables in R was converted to the appropriate type using either as.double() or as.integer(). If the wrong type is passed, it can result in a hard-to-catch error or unexpected results1.\nListing 2.3: Cross-correlation wrapping function\n\nxcorr2D_f0 &lt;- function(a, b) {\n  # Please adjust the path to your setup. In my machine,\n  dyn.load(\"AquaFortR_Codes/xcorr2D.so\")\n\n  # the full CC matrix\n  cc_row &lt;- nrow(a) + nrow(b) - 1\n  cc_col &lt;- ncol(a) + ncol(b) - 1\n  cc &lt;- matrix(1:c(cc_row * cc_col), byrow = FALSE, ncol = cc_col)\n\n  result &lt;- .Fortran(\"xcorr2d_f\",\n    m = as.integer(dim(a)[1]),\n    n = as.integer(dim(a)[2]),\n    p = as.integer(dim(b)[1]),\n    q = as.integer(dim(b)[2]),\n    k = as.integer(cc_row),\n    l = as.integer(cc_row),\n    a = as.double(a),\n    b = as.double(b),\n    cc = as.double(cc)\n  )$cc\n\n  return(result)\n}\nExample\nNow, we can use an example to compare the performance of the two functions. In order to do so, microbenchmark package needs to be installed, and ggplot2 is required for plotting.\nThe obtained benchmarking data allows (mbm) for a quantitative comparison of the computational efficiency between the two methods. By printing “mbm” in the console (print(mbm)) it is evident that Fortran outperforms the R implementation of 2D cross-correlation by a factor of 10. The significance of leveraging Fortran becomes evident in Figure 2.1.\nlibrary(microbenchmark)\nlibrary(ggplot2)\n\nset.seed(72)\n# Assume a\na &lt;- structure(runif(64), dim = c(8L, 8L))\n# Assume b\nb &lt;- structure(runif(64), dim = c(8L, 8L))\nmbm &lt;- microbenchmark(\n  xcorr2D_r = xcorr2D_r0(a, b),\n  xcorr2D_f = xcorr2D_f0(a, b)\n)\n\nautoplot(mbm) +\n  stat_summary(\n    fun = \"median\",\n    geom = \"crossbar\",\n    width = 0.6,\n    colour = \"red\"\n  )\n\n\n\n\n\n\nFigure 2.1: Performance comparison of 2D Cross-correlation in R and Fortran. Median is shown as red vertical line.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "scripts.html#sec-2Dxcorr",
    "href": "scripts.html#sec-2Dxcorr",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "",
    "text": "Note\n\n\n\nPlease use the terminal tab in Rstudio or open a new terminal using Alt+Shift+R",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "scripts.html#d-convolution",
    "href": "scripts.html#d-convolution",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "\n2.2 2D Convolution",
    "text": "2.2 2D Convolution\nConvolution and cross-correlation are both operations applied to images. Cross-correlation means sliding a kernel (filter) across an image while convolution means sliding a flipped kernel across an image. (Draelos, 2019). Therefore, the 2D convolution of an array \\(F\\), with dimension \\((M, N)\\), and array \\(G\\), with dimension \\((P, Q)\\), can be given as the array \\(CC\\) that has a dimension of \\((M+P-1, N+Q-1)\\). \\(hv\\) means that \\(G\\) is flipped.\n\\[\nCC_{(s,t)} = \\sum_{m = 0}^{M-1}\\sum_{n = 0}^{N-1} F_{(m,n)} G_{(m-s, n-t)}^{hv}\n\\]\nwhere \\(s\\) varies between \\(-(P-1)\\) and \\((M-1)\\) while \\(t\\) varies between \\(-(Q-1)\\) and \\((N-1)\\). \\(F\\) and \\(G \\in R\\).\nIt is true that we can just flip the second array and use the functions from Section 2.1. However, we are interested in the complete workflow.\nListing 2.4\n\n\n\nListing 2.4: Convolution in R\n\nconv2D_r0 &lt;- function(a, b) {\n  # the full convolution matrix\n  conv_row &lt;- nrow(a) + nrow(b) - 1\n  conv_col &lt;- ncol(a) + ncol(b) - 1\n  conv &lt;- matrix(1:c(conv_row * conv_col), byrow = FALSE, ncol = conv_col)\n\n  # obtain possible shifts\n  min_row_shift &lt;- -(nrow(b) - 1)\n  max_row_shift &lt;- (nrow(a) - 1)\n  min_col_shift &lt;- -(ncol(b) - 1)\n  max_col_shift &lt;- (ncol(a) - 1)\n\n  # Padded matrix\n  rows_padded &lt;- abs(min_row_shift) + nrow(a) + abs(max_row_shift)\n  cols_padded &lt;- abs(min_col_shift) + ncol(a) + abs(max_col_shift)\n  # a\n  padded_a &lt;- matrix(0, nrow = rows_padded, ncol = cols_padded)\n  padded_a[\n    (abs(min_row_shift) + 1):(abs(min_row_shift) + nrow(a)),\n    (abs(min_col_shift) + 1):(abs(min_col_shift) + ncol(a))\n  ] &lt;- a\n\n  for (icol in 1:conv_col) {\n    for (irow in 1:conv_row) {\n      iconv &lt;- irow + ((icol - 1) * conv_row)\n      cols &lt;- (icol):(icol + ncol(b) - 1)\n      rows &lt;- (irow):(irow + nrow(b) - 1)\n      # b\n      padded_b &lt;- array(0, dim = c(rows_padded, cols_padded))\n      # flip the kernel i.e. b\n      padded_b[rows, cols] &lt;- b[nrow(b):1, ncol(b):1]\n\n      conv[irow, icol] &lt;- sum(padded_a * padded_b)\n    }\n  }\n\n  return(conv)\n}\n\n\n\n\nListing 2.5\n\n\n\nListing 2.5: Convolution in Fortran\n\nsubroutine conv2d_f(m, n, p, q, k, l, a, b, conv)\n   implicit none\n   integer                                :: m, n, p, q, k, l, i, j\n   double precision, dimension(m, n)      :: a\n   double precision, dimension(p, q)      :: b, b_flipped\n   double precision, dimension(k, l)      :: conv\n   !     dummy vars\n   integer                               :: min_row_shift, min_col_shift\n   integer                               :: max_row_shift, max_col_shift\n   integer                               :: rows_padded, cols_padded\n   integer                               :: icol, irow, iconv, icol2, irow2\n   real, allocatable, dimension(:, :)    :: padded_a, padded_b\n\n   !     obtain possible shfits\n   min_row_shift = -1*(p - 1)\n   max_row_shift = m - 1\n   min_col_shift = -1*(q - 1)\n   max_col_shift = n - 1\n\n   !   Flip the kernel i.e. B\n   b_flipped = 0.0\n   do i = 1, p\n      do j = 1, q\n         b_flipped(p - i + 1, q - j + 1) = b(i, j)\n      end do\n   end do\n\n   !   Padded arrray\n   rows_padded = abs(min_row_shift) + m + abs(max_row_shift)\n   cols_padded = abs(min_col_shift) + n + abs(max_col_shift)\n   !    A\n   allocate (padded_a(rows_padded, cols_padded))\n   padded_a = 0.0\n   padded_a((abs(min_row_shift) + 1):(abs(min_row_shift) + m), &\n            (abs(min_col_shift) + 1):(abs(min_col_shift) + n)) = a\n\n   !    B\n   allocate (padded_b(rows_padded, cols_padded))\n   padded_b = 0.0\n   do icol = 1, l\n      do irow = 1, k\n         iconv = irow + ((icol - 1)*k)\n         icol2 = icol + q - 1\n         irow2 = irow + p - 1\n         padded_b(irow:irow2, icol:icol2) = b_flipped\n         conv(irow, icol) = sum(padded_a*padded_b)\n         padded_b = 0.0\n      end do\n   end do\nend subroutine conv2d_f\n\n\n\n\nYou might need some flags when compile Fortran subroutine, For example, to enable the generation of run-time check -fcheck=all. The code below shows two options to compile conv2D.f90 either by R or gfortran compiler.\n\n# R\nR CMD SHLIB conv2D.f90\n\n# gfortran\ngfortran -fpic -shared conv2D.f90 -o conv2D.so\n\nListing 2.6\n\n\n\nListing 2.6: Convolution wrapping function\n\nconv2D_f0 &lt;- function(a, b) {\n  require(dotCall64)\n  dyn.load(\"AquaFortR_Codes/conv2D.so\")\n\n  # the full convolution matrix\n  conv_row &lt;- nrow(a) + nrow(b) - 1\n  conv_col &lt;- ncol(a) + ncol(b) - 1\n  conv &lt;- matrix(0, byrow = FALSE, ncol = conv_col)\n\n  result &lt;- .C64(\"conv2d_f\",\n                 SIGNATURE = c(rep(\"integer\",6),\n                              rep(\"double\",3)),\n                 m = dim(a)[1],\n                 n = dim(a)[2],\n                 p = dim(b)[1],\n                 q = dim(b)[2],\n                 k = integer(conv_row),\n                 l = integer(conv_col),\n                 a = as.double(a),\n                 b = as.double(b),\n                 conv = as.double(conv))$conv\n\n  return(result)\n}\n\n\n\n\nSimilar to cross-correlation calculation, the Fortran implementation of convolution outperforms the R one by\n\nlibrary(microbenchmark)\nlibrary(ggplot2)\n\n\nset.seed(72)\n# Assume a\na &lt;- structure(runif(64), dim = c(8L, 8L))\n# Assume b\nb &lt;- structure(runif(64), dim = c(8L, 8L))\nmbm &lt;- microbenchmark(\n  conv2D_r = conv2D_r0(a, b),\n  conv2D_f = conv2D_f0(a, b)\n)\n\nautoplot(mbm) +\n  stat_summary(\n    fun = \"mean\",\n    geom = \"crossbar\",\n    width = 0.6,\n    colour = \"red\"\n  )\n\n\n\n\n\n\nFigure 2.2: Performance comparison of 2D Convolution in R and Fortran. Median is shown as red vertical line.\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nAfter learning about .Fortran() and .C64(), you can use one of the two examples above and compare the performance of the two interfaces using microbenchmark(). Which function is faster?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "scripts.html#convective-available-potential-energy-cape",
    "href": "scripts.html#convective-available-potential-energy-cape",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "\n2.3 Convective Available Potential Energy (CAPE)",
    "text": "2.3 Convective Available Potential Energy (CAPE)\n\n\n\nThe maximum buoyancy of an undiluted air parcel, related to the potential up-draft strength of thunderstorms.\n\n#|\nif (!require(AquaFortR)) {\n  remotes::install_github(\"AHomoudi/AquaFortR\", subdir = \"RPackage\")\n}\n\nlibrary(AquaFortR)\ndata(\"radiosonde\")\n\nTemperature &lt;- radiosonde$temp + 273.15 # K\nDewpoint &lt;- radiosonde$dpt + 273.15 # K\nPressure &lt;- radiosonde$pressure # hPa\n# Mixing ratio\nMixingRatio &lt;- mixing_ratio_from_dewpoint(Dewpoint, Pressure)\nt_parcel &lt;- Temperature[1]\ndwpt_parcel &lt;- Dewpoint[1]\nmr_parcel &lt;- MixingRatio[1]\n\nsource(\"AquaFortR_Codes/cape_r.R\")\nsource(\"AquaFortR_Codes/cape_f.R\")\n\n\nlibrary(microbenchmark)\nlibrary(ggplot2)\n\nmbm &lt;- microbenchmark(\n  cape_r = cape_r0(t_parcel, dwpt_parcel, mr_parcel,\n    Pressure, Temperature, MixingRatio,\n    vtc = TRUE\n  ),\n  cape_f = cape_f0(t_parcel, dwpt_parcel, mr_parcel,\n    Pressure, Temperature, MixingRatio,\n    vtc = TRUE\n  )\n)\n\nautoplot(mbm) +\n  stat_summary(\n    fun = \"mean\",\n    geom = \"crossbar\",\n    width = 0.3,\n    colour = \"green\"\n  )\n\n\n\n\n\n\nFigure 2.3: Performance comparison of CAPE in R and Fortran\n\n\n\n\nhttps://www.f5wx.com/pages/CAPECalc.htm\nhttps://geo.libretexts.org/Bookshelves/Meteorology_and_Climate_Science/Practical_Meteorology_(Stull)/14%3A_Thunderstorm_Fundamentals/14.03%3A_Section_4-\nhttps://journals.ametsoc.org/view/journals/clim/33/6/jcli-d-19-0461.1.xml\nhttps://www.weather.gov/source/zhu/ZHU_Training_Page/convective_parameters/Sounding_Stuff/MesoscaleParameters.html\n\n\n\n\nDraelos, R. (2019). Convolution vs. Cross-correlation. In Glass Box. https://glassboxmedicine.com/2019/07/26/convolution-vs-cross-correlation/\n\n\nSeelig, T., Deneke, H., Quaas, J., & Tesche, M. (2021). Life Cycle of Shallow Marine Cumulus Clouds From Geostationary Satellite Observations. Journal of Geophysical Research: Atmospheres, 126(22). https://doi.org/10.1029/2021JD035577\n\n\nWang, C. (2019). Kernel learning for visual perception. https://doi.org/10.32657/10220/47835\n\n\nWarren, M. A., Quartly, G. D., Shutler, J. D., Miller, P. I., & Yoshikawa, Y. (2016). Estimation of ocean surface currents from maximum cross correlation applied to GOCI geostationary satellite remote sensing data over the tsushima (korea) straits. Journal of Geophysical Research: Oceans, 121(9), 6993–7009. https://doi.org/https://doi.org/10.1002/2016JC011814\n\n\nWillert, C. E., & Gharib, M. (1991). Digital particle image velocimetry. Experiments in Fluids, 10(4), 181–193. https://doi.org/10.1007/BF00190388",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "scripts.html#footnotes",
    "href": "scripts.html#footnotes",
    "title": "2  Accelerate R Scripts with Fortran",
    "section": "",
    "text": "Writing R Extensions, 5.2 Interface functions .C and .Fortran↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Accelerate R Scripts with Fortran</span>"
    ]
  },
  {
    "objectID": "package.html",
    "href": "package.html",
    "title": "3  Accelerate R Packages with Fortran",
    "section": "",
    "text": "3.1 Brief Introduction to R Packages",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Accelerate R Packages with Fortran</span>"
    ]
  },
  {
    "objectID": "package.html#brief-introduction-to-r-packages",
    "href": "package.html#brief-introduction-to-r-packages",
    "title": "3  Accelerate R Packages with Fortran",
    "section": "",
    "text": "3.1.1 devtools package",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Accelerate R Packages with Fortran</span>"
    ]
  },
  {
    "objectID": "package.html#developing-aquafortr-package",
    "href": "package.html#developing-aquafortr-package",
    "title": "3  Accelerate R Packages with Fortran",
    "section": "3.2 Developing AquaFortR Package",
    "text": "3.2 Developing AquaFortR Package\n\n3.2.1 R function\n\n\n3.2.2 Fortran subroutine\n\niso_c_binidng\n\n\n\n3.2.3 C funtions\n\nC to Fortran\nR to C\n\n\n\n3.2.4 Package’s files",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Accelerate R Packages with Fortran</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "4  Summary",
    "section": "",
    "text": "4.1 Further Reading",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "summary.html#further-reading",
    "href": "summary.html#further-reading",
    "title": "4  Summary",
    "section": "",
    "text": "Fortran and R – Speed Things Up\nThe Need for Speed Part 1: Building an R Package with Fortran (or C)\nThe Need for Speed Part 2: C++ vs. Fortran vs. C\nWriting R Extensions\nExtend R with Fortran\nAdvanced R by Hadley Wickham\nFortran 90 Tutorial\nModern Fortran Tutorial\nFortran Wiki - Libraries\nFortran Best Practices\nHands-On Programming with R\nSpatial Data Science\nR for Data Science (2e)\nIntroduction to Environmental Data Science",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Chambers, F., John M. CRC Press Boca Raton. (2016). Extending\nr.http://slubdd.de/katalog?TN_libero_mab2\n\n\n\nChirila, D. B., & Lohmann, G. (2014). Introduction to modern\nfortran for the earth system sciences. Springer Berlin Heidelberg.\nhttps://books.google.de/books?id=bZCeBQAAQBAJ\n\n\nDraelos, R. (2019). Convolution vs. Cross-correlation. In Glass\nBox. https://glassboxmedicine.com/2019/07/26/convolution-vs-cross-correlation/\n\n\nMasuda, Y. (2020). Modern fortran tutorial. Introduction. https://masuday.github.io/fortran_tutorial/introduction.html\n\n\nMetcalf, M., Reid, J., & Cohen, M. (2018). Modern fortran\nexplained: Incorporating fortran 2018. OUP Oxford. https://books.google.de/books?id=sB1rDwAAQBAJ\n\n\nR Core Team. (2023). R: A language and environment for statistical\ncomputing. R Foundation for Statistical Computing. https://www.R-project.org/\n\n\nSeelig, T., Deneke, H., Quaas, J., & Tesche, M. (2021). Life Cycle of Shallow Marine Cumulus Clouds From\nGeostationary Satellite Observations. Journal of Geophysical\nResearch: Atmospheres, 126(22). https://doi.org/10.1029/2021JD035577\n\n\nWang, C. (2019). Kernel learning for visual perception. https://doi.org/10.32657/10220/47835\n\n\nWarren, M. A., Quartly, G. D., Shutler, J. D., Miller, P. I., &\nYoshikawa, Y. (2016). Estimation of ocean surface currents from maximum\ncross correlation applied to GOCI geostationary satellite remote sensing\ndata over the tsushima (korea) straits. Journal of Geophysical\nResearch: Oceans, 121(9), 6993–7009. https://doi.org/https://doi.org/10.1002/2016JC011814\n\n\nWickham, H. (2015). Advanced r. CRC Press. https://books.google.de/books?id=FfsYCwAAQBAJ\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for\ndata science import, tidy, transform, visualize, and model data\n(2nd edition). O’Reilly.http://slubdd.de/katalog?TN_libero_mab2\n\n\n\nWilkinson, M. D., Dumontier, M., Aalbersberg, Ij. J., Appleton, G.,\nAxton, M., Baak, A., Blomberg, N., Boiten, J.-W., da Silva Santos, L.\nB., Bourne, P. E., Bouwman, J., Brookes, A. J., Clark, T., Crosas, M.,\nDillo, I., Dumon, O., Edmunds, S., Evelo, C. T., Finkers, R., … Mons, B.\n(2016). The FAIR Guiding Principles for scientific\ndata management and stewardship. Scientific Data,\n3(1), 160018. https://doi.org/10.1038/sdata.2016.18\n\n\nWillert, C. E., & Gharib, M. (1991). Digital\nparticle image velocimetry. Experiments in Fluids,\n10(4), 181–193. https://doi.org/10.1007/BF00190388",
    "crumbs": [
      "References"
    ]
  }
]